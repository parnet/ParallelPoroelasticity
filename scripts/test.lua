---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maro.
--- DateTime: 30.10.21 13:45
---

test = test or {}
original = original or {}

function test.SolveNonlinearTimeProblem(
        u,
        domainDisc,
        newtonSolver,
        out,
        filename,
        timeScheme,
        orderOrTheta,
        startTime,
        endTime,
        maxStepSize,
        minStepSize,
        reductionFactor,
        bFinishTimeStep,
        useCheckpointing,
        postProcess,
        startTSNo,
        endTSNo,
        newtonLineSearchFallbacks,
        additionalFinishedConditions)

    if u == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No grid function for the solution specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if domainDisc == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No domain discretization specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if newtonSolver == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No nonlin. solver specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if timeScheme == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No time scheme specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if startTime == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: Start time not specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if endTime == nil and endTSNo == nil and (additionalFinishedConditions == nil or #additionalFinishedConditions == 0)  then
        print("SolveNonlinearTimeProblem: Illegal parameters: End time, number of steps or other finished conditions not specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if maxStepSize == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No max. time step specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    -- attach the given callbacks to a TimeIntegratorSubject
    -- if this class is transcribed into c++, just inherit from TimeIntegratorSubject and attach the callbacks
    local callbackDispatcher = TimeIntegratorSubject()
    if postProcess ~= nil then
        util.ParseTimeIntegratorCallbacks(callbackDispatcher, postProcess)
    end

    -- bound on t-stepper from machine precision (conservative)
    relPrecisionBound = 1e-12

    -- create the finished conditions
    local finishedTester = FinishedTester()
    if endTSNo ~= nil then
        maxStepsCondition = MaxStepsFinishedCondition(endTSNo)
        finishedTester:add_condition(maxStepsCondition)
    end
    if endTime ~= nil then
        temporalCondition = TemporalFinishedCondition(endTime,maxStepSize,relPrecisionBound)
        finishedTester:add_condition(temporalCondition)
    end
    if additionalFinishedConditions ~= nil then
        for i, fc in ipairs(additionalFinishedConditions) do
            finishedTester:add_condition(fc)
        end
    end

    -- check parameters
    if filename == nil then filename = "sol" end
    if minStepSize == nil then minStepSize = maxStepSize end
    if reductionFactor == nil then reductionFactor = 0.5 end
    if reductionFactor >= 1 then
        print("SolveNonlinearTimeProblem: Illegal parameters: reductionFactor must be < 1.")
        exit()
    end

    -- create time disc
    local timeDisc = util.CreateTimeDisc(domainDisc, timeScheme, orderOrTheta)


    -- print newtonSolver setup
    print("SolveNonlinearTimeProblem, Newton Solver setup:")
    print(newtonSolver:config_string())

    -- start
    local time = startTime
    local step = startTSNo or 0
    local nlsteps = 0;


    if useCheckpointing then
        --- Read Checkpoint if necessary
        if util.HasParamOption("-restartWithCheckpoint") then
            cp = util.ReadCheckpoint(u)
            if cp ~= nil then
                time = cp.myData.time
                step = cp.myData.step
            end
        end
    end

    -- write start solution
    print(">> Writing start values")
    if type(out) == "function" then out(u, step, time)
    elseif type(out) == "userdata" then out:print(filename, u, step, time)
    end

    -- store grid function in vector of  old solutions
    local solTimeSeries = SolutionTimeSeries()
    solTimeSeries:push(u:clone(), time)

    -- update newtonSolver
    newtonSolver:init(AssembledOperator(timeDisc, u:grid_level()))

    -- store old solution (used for reinit in multistep)
    local uOld
    if minStepSize <= maxStepSize * reductionFactor or newtonLineSearchFallbacks ~= nil then
        uOld = u:clone()
    end
    -- TODO: This can be optimized because the "old" solution is stored in
    -- solTimeSeries. Note that 'u' keeps not (always) the new solution but
    -- an iterate of the Newton method. If the Newton method fails, one should
    -- reset this iterate from the old solution: The Newton method needs a good
    -- initial approximation and its convergence depends on it strongly!

    -- set order for bdf to 1 (initially)
    if timeScheme:lower() == "bdf" then timeDisc:set_order(1) end

    -- bound on t-stepper from machine precision (conservative)
    relPrecisionBound = 1e-12

    local defaultLineSearch = newtonSolver:line_search()

    callbackDispatcher:notify_start(u, step, time, maxStepSize)

    local last_dt = currdt

    -- stop if size of remaining t-domain (relative to `maxStepSize`) lies below `relPrecisionBound`
    while not finishedTester:is_finished(time, step) do
        step = step+1
        print("++++++ TIMESTEP " .. step .. " BEGIN (current time: " .. time .. ") ++++++");

        local solver_call = 0;

        -- initial t-step size
        local currdt = maxStepSize
        if endTime ~= nil then
            -- adjust in case of over-estimation
            if time+currdt > endTime then currdt = endTime-time end
            -- adjust if size of remaining t-domain (relative to `maxStepSize`) lies below `relPrecisionBound`
            if ((endTime-(time+currdt))/maxStepSize < relPrecisionBound) then currdt = endTime-time end
        end

        -- try time step
        local bSuccess = false;
        while bSuccess == false do
            TerminateAbortedRun()

            print("++++++ Time step size: "..currdt);

            local newtonSuccess = false
            local newtonTry = 1
            newtonSolver:set_line_search(defaultLineSearch)

            -- try to solve the non-linear problem with different line-search strategies
            while newtonSuccess == false do
                -- get old solution if the restart with a smaller time step is possible
                if uOld ~= nil then
                    VecAssign(u, uOld)
                end

                local pp_res -- result of pre- and postprocess routines

                pp_res = true
                if util.debug_writer ~= nil then
                    util.debug_writer:enter_section ("TIMESTEP-"..step.."-Prepare-SolverCall-"..solver_call)
                end
                local pp_res = callbackDispatcher:notify_init_step(u, step, time, currdt)
                if util.debug_writer ~= nil then
                    util.debug_writer:leave_section ()
                end
                if pp_res == false then
                    print("\n++++++ Preparation of the time step failed.")
                    break
                end

                for stage = 1, timeDisc:num_stages() do
                    if timeDisc:num_stages() > 1 then
                        print("      +++ STAGE " .. stage .. " BEGIN ++++++")
                    end

                    -- call pre process
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-PreProcess-SolverCall-"..solver_call)
                    end
                    pp_res = callbackDispatcher:notify_preprocess_step(u, step, time, currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                    if pp_res == false then -- i.e. not nil, not something else, but "false"!
                        print("\n++++++ PreProcess failed.")
                        newtonSuccess = false
                        break
                    end


                    timeDisc:set_stage(stage)

                    -- setup time Disc for old solutions and timestep size
                    timeDisc:prepare_step(solTimeSeries, currdt)

                    -- enter debug section (if the debug_writer is specified)
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-SolverCall-"..solver_call)
                    end

                    -- prepare newton solver
                    if newtonSolver:prepare(u) == false then
                        print ("\n++++++ Newton solver failed."); exit();
                    end

                    -- apply newton solver
                    newtonSuccess = newtonSolver:apply(u)

                    -- exit debug section (if the debug_writer is specified)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end

                    -- start over again if failed
                    if newtonSuccess == false then break end

                    -- call post process
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-PostProcess-SolverCall-"..solver_call)
                    end
                    pp_res = callbackDispatcher:notify_postprocess_step(u, step, timeDisc:future_time(), currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                    if pp_res == false then -- i.e. not nil, not something else, but "false"!
                        print("\n++++++ PostProcess failed.")
                        newtonSuccess = false
                        break
                    end

                    --total_linsolver_calls()

                    -- push oldest solutions with new values to front, oldest sol pointer is poped from end
                    if timeScheme:lower() == "bdf" and step < orderOrTheta then
                        print("++++++ BDF: Increasing order to "..step+1)
                        timeDisc:set_order(step+1)
                        solTimeSeries:push(u:clone(), timeDisc:future_time())
                    else
                        local oldestSol = solTimeSeries:oldest()
                        VecAssign(oldestSol, u)
                        solTimeSeries:push_discard_oldest(oldestSol, timeDisc:future_time())
                    end

                    if not (bFinishTimeStep == nil) and bFinishTimeStep then
                        timeDisc:finish_step_elem(solTimeSeries, u:grid_level())
                    end

                    if timeDisc:num_stages() > 1 then
                        print("      +++ STAGE " .. stage .. " END   ++++++")
                    end
                end -- loop over the stages

                if newtonSuccess then
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-Finalize-SolverCall-"..solver_call)
                    end
                    last_dt = currdt
                    pp_res = callbackDispatcher:notify_finalize_step(u, step, time, currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                    if pp_res == false then -- i.e. not nil, not something else, but "false"!
                        write("\n++++++ Finalization of the time step failed.")
                        newtonSuccess = false
                        break
                    end
                end

                if newtonSuccess == false and newtonLineSearchFallbacks ~= nil then
                    if newtonLineSearchFallbacks[newtonTry] == nil or newtonSolver:last_num_newton_steps() == 0 then
                        write("\n++++++ Adaptive Newton failed.")
                        break
                    else
                        newtonSolver:set_line_search(newtonLineSearchFallbacks[newtonTry])
                        write("Restarting Newton method with line search fallback " .. newtonTry .. ".\n");
                        newtonTry = newtonTry + 1
                    end
                else
                    break
                end
            end -- while newtonSuccess == false

            -- call post process
            if newtonSuccess == false then
                currdt = currdt * reductionFactor;
                write("\n++++++ Newton method failed. ");
                write("Trying decreased stepsize " .. currdt .. ".\n");
                if(bSuccess == false and currdt < minStepSize) then
                    write("++++++ Time Step size "..currdt.." below minimal step ")
                    write("size "..minStepSize..". Cannot solve problem. Aborting.");
                    test.require(false, "Time Solver failed.")
                end
                bSuccess = false
                if rewindTimeStep ~= nil  then
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-Rewind-SolverCall-"..solver_call)
                    end
                    callbackDispatcher:notify_rewind_step(u, step, time, currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                end
            else
                -- update new time
                time = timeDisc:future_time()
                nlsteps = nlsteps + newtonSolver:num_newton_steps()
                bSuccess = true
            end

        end -- while bSuccess == false

        -- save this solution if the restard with a smaller time step is possible
        if uOld ~= nil then
            VecAssign (uOld, u)
        end

        -- plot solution
        if type(out) == "function" then out(u, step, time)
        elseif type(out) == "userdata" then out:print(filename, u, step, time)
        end

        print("++++++ TIMESTEP "..step.." END   (current time: " .. time .. ") ++++++");

        if useCheckpointing then
            ----------------------------------------------------------
            --- Write Checkpoint if necessary
            util.WriteCheckpointIntervallic(u, time, {time=time, step=step, endTime=endTime})
            ----------------------------------------------------------
        end
    end

    callbackDispatcher:notify_end(u, step, time, last_dt)

    if useCheckpointing and  timeDisc:num_stages() > 1 then
        ug_warning("WARNING: Checkpointing won't work at the moment with timeDisc:num_stages() > 1")
    end

    if type(out) == "userdata" then out:write_time_pvd(filename, u) end

    return step, time
end



function original.SolveNonlinearTimeProblem(
        u,
        domainDisc,
        newtonSolver,
        out,
        filename,
        timeScheme,
        orderOrTheta,
        startTime,
        endTime,
        maxStepSize,
        minStepSize,
        reductionFactor,
        bFinishTimeStep,
        useCheckpointing,
        postProcess,
        startTSNo,
        endTSNo,
        newtonLineSearchFallbacks,
        additionalFinishedConditions)

    if u == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No grid function for the solution specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if domainDisc == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No domain discretization specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if newtonSolver == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No nonlin. solver specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if timeScheme == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No time scheme specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if startTime == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: Start time not specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if endTime == nil and endTSNo == nil and (additionalFinishedConditions == nil or #additionalFinishedConditions == 0)  then
        print("SolveNonlinearTimeProblem: Illegal parameters: End time, number of steps or other finished conditions not specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    if maxStepSize == nil then
        print("SolveNonlinearTimeProblem: Illegal parameters: No max. time step specified.")
        util.PrintUsageOfSolveTimeProblem()
        exit()
    end

    -- attach the given callbacks to a TimeIntegratorSubject
    -- if this class is transcribed into c++, just inherit from TimeIntegratorSubject and attach the callbacks
    local callbackDispatcher = TimeIntegratorSubject()
    if postProcess ~= nil then
        util.ParseTimeIntegratorCallbacks(callbackDispatcher, postProcess)
    end

    -- bound on t-stepper from machine precision (conservative)
    relPrecisionBound = 1e-12

    -- create the finished conditions
    local finishedTester = FinishedTester()
    if endTSNo ~= nil then
        maxStepsCondition = MaxStepsFinishedCondition(endTSNo)
        finishedTester:add_condition(maxStepsCondition)
    end
    if endTime ~= nil then
        temporalCondition = TemporalFinishedCondition(endTime,maxStepSize,relPrecisionBound)
        finishedTester:add_condition(temporalCondition)
    end
    if additionalFinishedConditions ~= nil then
        for i, fc in ipairs(additionalFinishedConditions) do
            finishedTester:add_condition(fc)
        end
    end

    -- check parameters
    if filename == nil then filename = "sol" end
    if minStepSize == nil then minStepSize = maxStepSize end
    if reductionFactor == nil then reductionFactor = 0.5 end
    if reductionFactor >= 1 then
        print("SolveNonlinearTimeProblem: Illegal parameters: reductionFactor must be < 1.")
        exit()
    end

    -- create time disc
    local timeDisc = util.CreateTimeDisc(domainDisc, timeScheme, orderOrTheta)


    -- print newtonSolver setup
    print("SolveNonlinearTimeProblem, Newton Solver setup:")
    print(newtonSolver:config_string())

    -- start
    local time = startTime
    local step = startTSNo or 0
    local nlsteps = 0;


    if useCheckpointing then
        --- Read Checkpoint if necessary
        if util.HasParamOption("-restartWithCheckpoint") then
            cp = util.ReadCheckpoint(u)
            if cp ~= nil then
                time = cp.myData.time
                step = cp.myData.step
            end
        end
    end

    -- write start solution
    print(">> Writing start values")
    if type(out) == "function" then out(u, step, time)
    elseif type(out) == "userdata" then out:print(filename, u, step, time)
    end

    -- store grid function in vector of  old solutions
    local solTimeSeries = SolutionTimeSeries()
    solTimeSeries:push(u:clone(), time)

    -- update newtonSolver
    newtonSolver:init(AssembledOperator(timeDisc, u:grid_level()))

    -- store old solution (used for reinit in multistep)
    local uOld
    if minStepSize <= maxStepSize * reductionFactor or newtonLineSearchFallbacks ~= nil then
        uOld = u:clone()
    end
    -- TODO: This can be optimized because the "old" solution is stored in
    -- solTimeSeries. Note that 'u' keeps not (always) the new solution but
    -- an iterate of the Newton method. If the Newton method fails, one should
    -- reset this iterate from the old solution: The Newton method needs a good
    -- initial approximation and its convergence depends on it strongly!

    -- set order for bdf to 1 (initially)
    if timeScheme:lower() == "bdf" then timeDisc:set_order(1) end

    -- bound on t-stepper from machine precision (conservative)
    relPrecisionBound = 1e-12

    local defaultLineSearch = newtonSolver:line_search()

    callbackDispatcher:notify_start(u, step, time, maxStepSize)

    local last_dt = currdt

    -- stop if size of remaining t-domain (relative to `maxStepSize`) lies below `relPrecisionBound`
    while not finishedTester:is_finished(time, step) do
        step = step+1
        print("++++++ TIMESTEP " .. step .. " BEGIN (current time: " .. time .. ") ++++++");

        local solver_call = 0;

        -- initial t-step size
        local currdt = maxStepSize
        if endTime ~= nil then
            -- adjust in case of over-estimation
            if time+currdt > endTime then currdt = endTime-time end
            -- adjust if size of remaining t-domain (relative to `maxStepSize`) lies below `relPrecisionBound`
            if ((endTime-(time+currdt))/maxStepSize < relPrecisionBound) then currdt = endTime-time end
        end

        -- try time step
        local bSuccess = false;
        while bSuccess == false do
            TerminateAbortedRun()

            print("++++++ Time step size: "..currdt);

            local newtonSuccess = false
            local newtonTry = 1
            newtonSolver:set_line_search(defaultLineSearch)

            -- try to solve the non-linear problem with different line-search strategies
            while newtonSuccess == false do
                -- get old solution if the restart with a smaller time step is possible
                if uOld ~= nil then
                    VecAssign(u, uOld)
                end

                local pp_res -- result of pre- and postprocess routines

                pp_res = true
                if util.debug_writer ~= nil then
                    util.debug_writer:enter_section ("TIMESTEP-"..step.."-Prepare-SolverCall-"..solver_call)
                end
                local pp_res = callbackDispatcher:notify_init_step(u, step, time, currdt)
                if util.debug_writer ~= nil then
                    util.debug_writer:leave_section ()
                end
                if pp_res == false then
                    print("\n++++++ Preparation of the time step failed.")
                    break
                end

                for stage = 1, timeDisc:num_stages() do
                    if timeDisc:num_stages() > 1 then
                        print("      +++ STAGE " .. stage .. " BEGIN ++++++")
                    end

                    -- call pre process
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-PreProcess-SolverCall-"..solver_call)
                    end
                    pp_res = callbackDispatcher:notify_preprocess_step(u, step, time, currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                    if pp_res == false then -- i.e. not nil, not something else, but "false"!
                        print("\n++++++ PreProcess failed.")
                        newtonSuccess = false
                        break
                    end


                    timeDisc:set_stage(stage)

                    -- setup time Disc for old solutions and timestep size
                    timeDisc:prepare_step(solTimeSeries, currdt)

                    -- enter debug section (if the debug_writer is specified)
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-SolverCall-"..solver_call)
                    end

                    -- prepare newton solver
                    if newtonSolver:prepare(u) == false then
                        print ("\n++++++ Newton solver failed."); exit();
                    end

                    -- apply newton solver
                    newtonSuccess = newtonSolver:apply(u)

                    -- exit debug section (if the debug_writer is specified)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end

                    -- start over again if failed
                    if newtonSuccess == false then break end

                    -- call post process
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-PostProcess-SolverCall-"..solver_call)
                    end
                    pp_res = callbackDispatcher:notify_postprocess_step(u, step, timeDisc:future_time(), currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                    if pp_res == false then -- i.e. not nil, not something else, but "false"!
                        print("\n++++++ PostProcess failed.")
                        newtonSuccess = false
                        break
                    end

                    --total_linsolver_calls()

                    -- push oldest solutions with new values to front, oldest sol pointer is poped from end
                    if timeScheme:lower() == "bdf" and step < orderOrTheta then
                        print("++++++ BDF: Increasing order to "..step+1)
                        timeDisc:set_order(step+1)
                        solTimeSeries:push(u:clone(), timeDisc:future_time())
                    else
                        local oldestSol = solTimeSeries:oldest()
                        VecAssign(oldestSol, u)
                        solTimeSeries:push_discard_oldest(oldestSol, timeDisc:future_time())
                    end

                    if not (bFinishTimeStep == nil) and bFinishTimeStep then
                        timeDisc:finish_step_elem(solTimeSeries, u:grid_level())
                    end

                    if timeDisc:num_stages() > 1 then
                        print("      +++ STAGE " .. stage .. " END   ++++++")
                    end
                end -- loop over the stages

                if newtonSuccess then
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-Finalize-SolverCall-"..solver_call)
                    end
                    last_dt = currdt
                    pp_res = callbackDispatcher:notify_finalize_step(u, step, time, currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                    if pp_res == false then -- i.e. not nil, not something else, but "false"!
                        write("\n++++++ Finalization of the time step failed.")
                        newtonSuccess = false
                        break
                    end
                end

                if newtonSuccess == false and newtonLineSearchFallbacks ~= nil then
                    if newtonLineSearchFallbacks[newtonTry] == nil or newtonSolver:last_num_newton_steps() == 0 then
                        write("\n++++++ Adaptive Newton failed.")
                        break
                    else
                        newtonSolver:set_line_search(newtonLineSearchFallbacks[newtonTry])
                        write("Restarting Newton method with line search fallback " .. newtonTry .. ".\n");
                        newtonTry = newtonTry + 1
                    end
                else
                    break
                end
            end -- while newtonSuccess == false

            -- call post process
            if newtonSuccess == false then
                currdt = currdt * reductionFactor;
                write("\n++++++ Newton method failed. ");
                write("Trying decreased stepsize " .. currdt .. ".\n");
                if(bSuccess == false and currdt < minStepSize) then
                    write("++++++ Time Step size "..currdt.." below minimal step ")
                    write("size "..minStepSize..". Cannot solve problem. Aborting.");
                    test.require(false, "Time Solver failed.")
                end
                bSuccess = false
                if rewindTimeStep ~= nil  then
                    if util.debug_writer ~= nil then
                        util.debug_writer:enter_section ("TIMESTEP-"..step.."-Rewind-SolverCall-"..solver_call)
                    end
                    callbackDispatcher:notify_rewind_step(u, step, time, currdt)
                    if util.debug_writer ~= nil then
                        util.debug_writer:leave_section ()
                    end
                end
            else
                -- update new time
                time = timeDisc:future_time()
                nlsteps = nlsteps + newtonSolver:num_newton_steps()
                bSuccess = true
            end

        end -- while bSuccess == false

        -- save this solution if the restard with a smaller time step is possible
        if uOld ~= nil then
            VecAssign (uOld, u)
        end

        -- plot solution
        if type(out) == "function" then out(u, step, time)
        elseif type(out) == "userdata" then out:print(filename, u, step, time)
        end

        print("++++++ TIMESTEP "..step.." END   (current time: " .. time .. ") ++++++");

        if useCheckpointing then
            ----------------------------------------------------------
            --- Write Checkpoint if necessary
            util.WriteCheckpointIntervallic(u, time, {time=time, step=step, endTime=endTime})
            ----------------------------------------------------------
        end
    end

    callbackDispatcher:notify_end(u, step, time, last_dt)

    if useCheckpointing and  timeDisc:num_stages() > 1 then
        ug_warning("WARNING: Checkpointing won't work at the moment with timeDisc:num_stages() > 1")
    end

    if type(out) == "userdata" then out:write_time_pvd(filename, u) end

    return step, time
end